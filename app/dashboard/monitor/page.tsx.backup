"use client";

import { useState, useEffect, useRef } from "react";
import { Terminal, Wifi, WifiOff, Pause, Play } from "lucide-react";
import { DashboardLayout } from "@/components/dashboard-layout";
import { AuthGuard } from "@/components/auth-guard";

interface MLPrediction {
  is_attack: boolean;
  confidence: number;
  attack_probability: number;
  model_version?: string;
  flow_id?: string;
  client_id?: string;
  resource_id?: string;
}

interface PredictionLog {
  id: string;
  timestamp: Date;
  predictions: MLPrediction[];
  source: string;
  client_id: string;
  resource_id: string;
  processing_time_ms?: number;
}

export default function MonitorPage() {
  const [predictionLogs, setPredictionLogs] = useState<PredictionLog[]>([]);
  const [isConnected, setIsConnected] = useState(false);
  const [isPaused, setIsPaused] = useState(false);
  const [connectionError, setConnectionError] = useState<string | null>(null);
  const [stats, setStats] = useState({
    totalPredictions: 0,
    attackCount: 0,
    benignCount: 0,
    avgConfidence: 0,
  });

  const terminalRef = useRef<HTMLDivElement>(null);
  const wsRef = useRef<WebSocket | null>(null);
  const maxLogs = 1000; // Keep last 1000 predictions

  // Auto-scroll to bottom
  const scrollToBottom = () => {
    if (terminalRef.current && !isPaused) {
      terminalRef.current.scrollTop = terminalRef.current.scrollHeight;
    }
  };

  // Update statistics
  const updateStats = (newPredictions: MLPrediction[]) => {
    setStats((prev) => {
      const attackCount = newPredictions.filter((p) => p.is_attack).length;
      const benignCount = newPredictions.length - attackCount;
      const avgConf = newPredictions.reduce((sum, p) => sum + p.confidence, 0) / newPredictions.length;

      return {
        totalPredictions: prev.totalPredictions + newPredictions.length,
        attackCount: prev.attackCount + attackCount,
        benignCount: prev.benignCount + benignCount,
        avgConfidence:
          (prev.avgConfidence * prev.totalPredictions + avgConf * newPredictions.length) /
          (prev.totalPredictions + newPredictions.length),
      };
    });
  };

  // WebSocket connection to backend
  const connectWebSocket = () => {
    try {
      setConnectionError(null);
      console.log("üîå Connecting to WebSocket...");

      // Connect to WebSocket endpoint that streams Redis data
      const ws = new WebSocket("ws://localhost:23335/ws/ml/live");

      ws.onopen = () => {
        console.log("‚úÖ WebSocket connected");
        setIsConnected(true);
        setConnectionError(null);
      };

      ws.onmessage = (event) => {
        if (isPaused) return;

        try {
          const rawData = JSON.parse(event.data);
          console.log("üì° Received Redis data:", rawData);

          // Skip heartbeat and connection status messages
          if (rawData.type === "heartbeat" || rawData.type === "connection_status" || rawData.type === "pong") {
            return;
          }

          // Parse the actual message from Redis (it's in the 'msg' field)
          let actualData;
          if (rawData.msg) {
            actualData = JSON.parse(rawData.msg);
          } else {
            actualData = rawData;
          }

          console.log("üìä Parsed prediction data:", actualData);

          // Extract predictions from batch_results or direct predictions
          const predictions = actualData.batch_results?.predictions || actualData.predictions || [];
          
          // Add each individual prediction as a separate log entry
          predictions.forEach((prediction: MLPrediction, index: number) => {
            const newLog: PredictionLog = {
              id: `${actualData.message_id || Date.now()}-${index}`,
              timestamp: new Date(),
              predictions: [prediction],
              source: actualData.source || "ml-pipeline",
              client_id: actualData.client_id || "unknown",
              resource_id: actualData.resource_id || "unknown",
              processing_time_ms: actualData.batch_results?.statistics?.processing_time_ms,
            };

            setPredictionLogs((prev) => {
              const updated = [...prev, newLog];
              return updated.slice(-maxLogs); // Keep only recent logs
            });

            updateStats([prediction]);
          });

          setTimeout(scrollToBottom, 100);
        } catch (error) {
          console.error("‚ùå Failed to parse WebSocket message:", error);
        }
      };

      ws.onclose = () => {
        console.log("üîå WebSocket disconnected");
        setIsConnected(false);
        // Reconnect after 3 seconds
        setTimeout(connectWebSocket, 3000);
      };

      ws.onerror = (error) => {
        console.error("‚ùå WebSocket error:", error);
        setConnectionError("WebSocket connection failed");
        setIsConnected(false);
      };

      wsRef.current = ws;
    } catch (error) {
      console.error("‚ùå Failed to connect WebSocket:", error);
      setConnectionError("Failed to establish WebSocket connection");
      setIsConnected(false);
    }
  };

  useEffect(() => {
    connectWebSocket();

    return () => {
      if (wsRef.current) {
        wsRef.current.close();
      }
    };
  }, []); // eslint-disable-line react-hooks/exhaustive-deps

  const formatTimestamp = (date: Date) => {
    return date.toLocaleTimeString() + "." + date.getMilliseconds().toString().padStart(3, "0");
  };

  const getPredictionColor = (prediction: MLPrediction) => {
    if (prediction.is_attack) {
      return prediction.confidence > 0.8 ? "text-red-400" : "text-orange-400";
    }
    return prediction.confidence > 0.8 ? "text-green-400" : "text-blue-400";
  };

  const getPredictionIcon = (prediction: MLPrediction) => {
    if (prediction.is_attack) {
      return prediction.confidence > 0.8 ? "üî¥" : "üü°";
    }
    return prediction.confidence > 0.8 ? "üü¢" : "üîµ";
  };

  const togglePause = () => {
    setIsPaused(!isPaused);
  };

  return (
    <AuthGuard>
      <DashboardLayout>
        <div className="h-full bg-black text-green-400 font-mono flex flex-col">
          {/* Terminal Header */}
          <div className="border-b border-green-500/30 p-4 bg-gray-900/50">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-3">
                <Terminal className="w-6 h-6" />
                <div>
                  <h1 className="text-xl font-bold">ML Prediction Stream Monitor</h1>
                  <p className="text-sm text-green-300/70">Real-time Redis stream ‚Ä¢ Live ML predictions</p>
                </div>
              </div>

              <div className="flex items-center gap-4">
                {/* Connection Status */}
                <div className="flex items-center gap-2">
                  {isConnected ? (
                    <Wifi className="w-5 h-5 text-green-400" />
                  ) : (
                    <WifiOff className="w-5 h-5 text-red-400" />
                  )}
                  <span className="text-sm">{isConnected ? "Connected" : "Disconnected"}</span>
                </div>

                {/* Pause/Play */}
                <button
                  onClick={togglePause}
                  className="flex items-center gap-2 px-3 py-1 border border-green-500/30 rounded hover:bg-green-500/10"
                >
                  {isPaused ? <Play className="w-4 h-4" /> : <Pause className="w-4 h-4" />}
                  {isPaused ? "Resume" : "Pause"}
                </button>

                {/* Stats */}
                <div className="text-right text-sm">
                  <div className="text-green-300">
                    Total: {stats.totalPredictions} |
                    <span className="text-red-400 ml-1">Attacks: {stats.attackCount}</span> |
                    <span className="text-green-400 ml-1">Benign: {stats.benignCount}</span>
                  </div>
                  <div className="text-green-300/70">Avg Confidence: {(stats.avgConfidence * 100).toFixed(1)}%</div>
                </div>
              </div>
            </div>
          </div>

          {/* Connection Error */}
          {connectionError && (
            <div className="p-3 bg-red-900/30 border-b border-red-500/30 text-red-400">‚ùå {connectionError}</div>
          )}

          {/* Terminal Output */}
          <div
            ref={terminalRef}
            className="flex-1 overflow-y-auto p-4 space-y-1 bg-black"
            style={{ fontFamily: 'Monaco, "Lucida Console", monospace' }}
          >
            {predictionLogs.length === 0 ? (
              <div className="text-center py-8 text-green-300/50">
                <Terminal className="w-12 h-12 mx-auto mb-4 opacity-50" />
                <p>Waiting for ML predictions...</p>
                <p className="text-sm mt-2">{isConnected ? "Connected to Redis stream" : "Connecting to backend..."}</p>
              </div>
            ) : (
              predictionLogs.map((log) => (
                <div key={log.id} className="py-1">
                  {/* Pure Prediction Display */}
                  {log.predictions.map((prediction, predIndex) => (
                    <div key={predIndex} className={`${getPredictionColor(prediction)} leading-tight`}>
                      <span className="mr-2">{getPredictionIcon(prediction)}</span>
                      <span className="font-semibold">
                        {prediction.is_attack ? "ATTACK" : "BENIGN"}
                      </span>
                      <span className="text-white/60 ml-3">
                        conf: {(prediction.confidence * 100).toFixed(1)}%
                      </span>
                      <span className="text-white/40 ml-3">
                        prob: {(prediction.attack_probability * 100).toFixed(1)}%
                      </span>
                      <span className="text-gray-500 ml-3 text-xs">
                        {formatTimestamp(log.timestamp)}
                      </span>
                    </div>
                  ))}
                </div>
              ))
            )
            )}
          </div>

          {/* Terminal Footer */}
          <div className="border-t border-green-500/30 p-2 bg-gray-900/50 text-sm text-green-300/70">
            <div className="flex justify-between items-center">
              <span>
                {isPaused ? "‚è∏Ô∏è Stream Paused" : "‚ñ∂Ô∏è Live Stream"} | Showing last{" "}
                {Math.min(predictionLogs.length, maxLogs)} predictions
              </span>
              <span>{isConnected ? "üü¢ Redis WebSocket Active" : "üî¥ Disconnected"}</span>
            </div>
          </div>
        </div>
      </DashboardLayout>
    </AuthGuard>
  );
}
